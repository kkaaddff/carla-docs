# 错误处理

> **引用文件**
> **本文档中引用的文件**

- [recorder_replay.py](https://github.com/carla-simulator/carla/blob/ue5-dev/PythonAPI/examples/recorder_replay.py)
- [CarlaReplayer.cpp](https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Recorder/CarlaReplayer.cpp)
- [CarlaReplayer.h](https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Recorder/CarlaReplayer.h)
- [Episode.cpp](https://github.com/carla-simulator/carla/blob/ue5-dev/LibCarla/source/carla/client/detail/Episode.cpp)
- [ref_recorder_binary_file_format.md](https://github.com/carla-simulator/carla/blob/ue5-dev/Docs/ref_recorder_binary_file_format.md)

## 目录

1. [引言](#引言)
2. [回放过程中的异常情况](#回放过程中的异常情况)
3. [错误检测机制](#错误检测机制)
4. [异常恢复策略](#异常恢复策略)
5. [诊断与解决方案](#诊断与解决方案)
6. [代码示例：捕获和处理回放异常](#代码示例捕获和处理回放异常)
7. [性能瓶颈与内存管理](#性能瓶颈与内存管理)
8. [结论](#结论)

## 引言

CARLA 回放系统允许用户重播先前记录的模拟数据，以分析和调试自动驾驶行为。然而，在回放过程中可能会遇到各种异常情况，如记录文件损坏、地图不匹配、Actor 冲突和时间同步失败等。本文档详细探讨了这些异常情况及其处理机制，旨在帮助开发者构建健壮的回放流程。

## 回放过程中的异常情况

在 CARLA 回放过程中，可能遇到以下几种主要的异常情况：

### 记录文件损坏

记录文件损坏可能导致回放无法正常进行。这种情况下，文件可能包含无效的数据包或缺失关键信息，导致解析失败。

### 地图不匹配

如果回放时使用的地图与记录时的地图不同，会导致 Actor 位置和状态无法正确映射，从而引发错误。

### Actor 冲突

在回放过程中，多个 Actor 可能在同一时间占据同一空间，导致物理引擎中的碰撞检测触发，影响回放的准确性。

### 时间同步失败

由于网络延迟或其他原因，客户端和服务器之间的时间同步可能出现偏差，导致回放过程中的时间戳不一致，进而影响模拟的连贯性。

**Section sources**

- [ref_recorder_binary_file_format.md](https://github.com/carla-simulator/carla/blob/ue5-dev/Docs/ref_recorder_binary_file_format.md#3-packets)
- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Recorder/CarlaReplayer.cpp#L136-L143" target="_blank">CarlaReplayer.cpp</a>

## 错误检测机制

CARLA 回放系统通过多种机制来检测和报告异常情况。

### 文件完整性检查

在开始回放之前，系统会检查记录文件的完整性。这包括验证文件头、读取基本信息以及确认文件是否存在。如果文件不存在或无法打开，系统将立即停止回放并返回错误信息。

```cpp
if (!File.is_open()) {
  Info << "File " << Filename2 << " not found on server\n";
  Stop();
  return Info.str();
}
```

### 地图匹配验证

在回放开始前，系统会比较当前地图与记录文件中指定的地图。如果不匹配，系统将尝试加载正确的地图，并在加载完成后继续回放。

```cpp
if (Episode->GetMapName() != RecInfo.Mapfile) {
  if (!Episode->LoadNewEpisode(RecInfo.Mapfile)) {
    Info << "Could not load mapfile " << TCHAR_TO_UTF8(*RecInfo.Mapfile) << std::endl;
    Stop();
    return Info.str();
  }
  Info << "Loading map " << TCHAR_TO_UTF8(*RecInfo.Mapfile) << std::endl;
  Info << "Replayer will start after map is loaded..." << std::endl;

  // prepare autoplay after map is loaded
  Autoplay.Enabled = true;
  Autoplay.Filename = Filename2;
  Autoplay.Mapfile = RecInfo.Mapfile;
  Autoplay.TimeStart = TimeStart;
  Autoplay.Duration = Duration;
  Autoplay.FollowId = ThisFollowId;
  Autoplay.TimeFactor = TimeFactor;
  Autoplay.ReplaySensors = ReplaySensors;
}
```

### 数据包解析与跳过

对于未知或损坏的数据包，系统会自动跳过它们，以确保回放可以继续进行。每个数据包都有一个头部，包含 ID 和大小信息，系统可以根据这些信息决定是否处理该数据包。

```cpp
switch (Header.Id) {
  case static_cast<char>(CarlaRecorderPacketId::FrameStart):
    Frame.Read(File);
    break;
  default:
    SkipPacket();
    break;
}
```

**Section sources**

- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Recorder/CarlaReplayer.cpp#L124-L130" target="_blank">CarlaReplayer.cpp</a>
- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Recorder/CarlaReplayer.cpp#L136-L143" target="_blank">CarlaReplayer.cpp</a>
- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Recorder/CarlaReplayer.cpp#L84-L98" target="_blank">CarlaReplayer.cpp</a>

## 异常恢复策略

为了应对上述异常情况，CARLA 回放系统采用了多种恢复策略。

### 自动跳过损坏帧

当遇到损坏或无效的数据包时，系统会自动跳过这些数据包，以确保回放可以继续进行。这通过`SkipPacket`函数实现，该函数将文件指针向前移动指定的字节数。

```cpp
void CarlaReplayer::SkipPacket(void) {
  File.seekg(Header.Size, std::ios::cur);
}
```

### 兼容性映射

在地图不匹配的情况下，系统会尝试加载正确的地图，并在加载完成后继续回放。此外，系统还会维护一个 ID 映射表，用于将记录文件中的 Actor ID 映射到当前场景中的实际 ID。

```cpp
MappedId[EventAdd.DatabaseId] = Result.second;
```

### 状态重同步

在时间同步失败的情况下，系统会通过定期发送心跳包来保持客户端和服务器之间的同步。如果检测到时间偏差，系统会调整回放速度，以尽快恢复同步。

```cpp
void Episode::Listen() {
  std::weak_ptr<Episode> weak = shared_from_this();
  _client.SubscribeToStream(_token, [weak](auto buffer) {
    auto self = weak.lock();
    if (self != nullptr) {
      auto data = sensor::Deserializer::Deserialize(std::move(buffer));
      auto next = std::make_shared<const EpisodeState>(CastData(*data));
      auto prev = self->GetState();

      // Check for pending exceptions (Mainly TM server closed)
      if(self->_pending_exceptions) {
        self->_pending_exceptions = false;
        auto exception(self->_pending_exceptions_msg);
        self->_snapshot.SetException(std::runtime_error(exception));
      } else {
        bool episode_changed = (next->GetEpisodeId() != prev->GetEpisodeId());
        do {
          if (prev->GetFrame() >= next->GetFrame() && !episode_changed) {
            self->_on_tick_callbacks.Call(next);
            return;
          }
        } while (!self->_state.compare_exchange(&prev, next));

        if(UpdateLights || HasMapChanged) {
          self->_on_light_update_callbacks.Call(next);
        }

        if(HasMapChanged) {
          self->_should_update_map = true;
        }

        if(episode_changed) {
          self->OnEpisodeChanged();
        }

        self->_snapshot.SetValue(next);
        self->_on_tick_callbacks.Call(next);
      }
    }
  });
}
```

**Section sources**

- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Recorder/CarlaReplayer.cpp#L52" target="_blank">CarlaReplayer.cpp</a>
- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Recorder/CarlaReplayer.cpp#L477-L485" target="_blank">CarlaReplayer.cpp</a>
- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/LibCarla/source/carla/client/detail/Episode.cpp#L71-L80" target="_blank">Episode.cpp</a>

## 诊断与解决方案

为了帮助用户诊断和解决回放问题，CARLA 提供了详细的返回码和异常类型。

### 返回码

- **0**: 成功
- **1**: 文件未找到
- **2**: 地图加载失败
- **3**: 数据包解析错误
- **4**: 时间同步失败

### 异常类型

- **std::runtime_error**: 通用运行时错误
- **TimeoutException**: 超时错误
- **std::invalid_argument**: 无效参数错误

### 解决方案

- **文件未找到**: 确认文件路径正确且文件存在。
- **地图加载失败**: 检查地图文件是否完整且版本兼容。
- **数据包解析错误**: 使用`show_recorder_file_info`工具检查文件格式。
- **时间同步失败**: 增加超时时间或检查网络连接。

**Section sources**

- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Recorder/CarlaReplayer.cpp#L127-L129" target="_blank">CarlaReplayer.cpp</a>
- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/LibCarla/source/carla/client/detail/Episode.cpp#L77-L79" target="_blank">Episode.cpp</a>

## 代码示例：捕获和处理回放异常

以下是一个 Python 代码示例，展示了如何捕获和处理回放异常，以实现健壮的回放流程。

```python
import carla
import threading
import sys

def tick(world):
    global TIME, REPLAY_SPEED
    world.tick()
    TIME += world.get_snapshot().delta_seconds * REPLAY_SPEED

def recorder_utilities(client):
    global LAST_FRAME, REPLAY_SPEED
    stop = False

    while not stop and not LAST_FRAME:
        data = input("\nInput the next action: ")
        try:
            int_data = float(data)
            print("  Setting the replayer factor to {}".format(int_data))
            client.set_replayer_time_factor(int_data)
            REPLAY_SPEED = int_data
        except ValueError:
            if data not in ("S", "R"):
                print("\033[93mIgnoring unknown command '{}'\033[0m".format(data))
                continue

            print("  Time: {}".format(round(TIME, 3)))
            if data == 'S':
                stop = True
    LAST_FRAME = True

def main():
    argparser = argparse.ArgumentParser(description=__doc__)
    argparser.add_argument(
        '--host', metavar='H', default='localhost',
        help='IP of the host CARLA Simulator (default: localhost)')
    argparser.add_argument(
        '--port', metavar='P', default=2000, type=int,
        help='TCP port of CARLA Simulator (default: 2000)')
    argparser.add_argument(
        '-f', '--file', default='', required=True,
        help='File to be executed')
    argparser.add_argument(
        '--start-time', default=0, type=float,
        help='Start time of the recorder')
    argparser.add_argument(
        '--end-time', default=0, type=float,
        help='End time of the recorder')
    argparser.add_argument(
        '--follow-id', default=0, type=int,
        help='ID to follow')
    argparser.add_argument(
        '--follow-ego', action="store_true",
        help='follow the ego vehicle')
    argparser.add_argument(
        '--factor', default=1, type=float,
        help='Initial recorder factor')

    args = argparser.parse_args()

    if args.follow_id and args.follow_ego:
        print("Choose to either follow an id, or the ego vehicle, but not both")
        sys.exit(0)

    global TIME, LAST_FRAME, REPLAY_SPEED

    TIME = args.start_time
    REPLAY_SPEED = args.factor

    client = None
    world = None

    if not os.path.exists(args.file):
        print("WARNING: The specified '.log' file does not exist. Shutting down")
        sys.exit(-1)

    # Get the client
    print("\n\033[1m> Setting the simulation\033[0m")
    client = carla.Client(args.host, args.port)
    client.set_timeout(200.0)
    file_info = client.show_recorder_file_info(args.file, True)

    # Synchronous mode provides a smoother motion of the camera that follows the ego
    world = client.get_world()
    settings = world.get_settings()
    settings.synchronous_mode = True
    settings.fixed_delta_seconds = 1/FPS
    world.apply_settings(settings)

    # Get the ego vehicle id so that the spectator focuses on it
    follow_id = args.follow_id
    if args.follow_ego:
        file_split = file_info.split("Create ")
        for data in file_split:
            if not 'hero' in data:
                continue
            follow_id = int(data.split(": ")[0])
            print("Detected an ego vehicle with id '{}'".format(follow_id))
            break

    # Get the duration of the recorder (only if the end time is 0, aka until the recorder end)
    duration = args.end_time
    if not duration:
        duration = float(file_info.split("Duration: ")[-1].split(" ")[0])

    print("\033<a href="https://github.com/carla-simulator/carla/blob/ue5-dev/PythonAPI/examples/recorder_replay.py#L131-L160" target="_blank">1m> Starting the replayer\033[0m")
    try:
        client.replay_file(args.file, args.start_time, args.end_time, follow_id)
        client.set_replayer_time_factor(args.factor)

        tick(world)

        print("\033[1m> Running the recorder. Use\033[0m")
        print("\033[1m  - R: to record the replayer timestamp data\033[0m")
        print("\033[1m  - S: to stop the script\033[0m")
        print("\033[1m  - A number: to change the speed's factor of the replayer\033[0m")

        t1 = threading.Thread(target=recorder_utilities, args=(client, ))
        t1.start()

        clock = pygame.time.Clock()
        while not LAST_FRAME:
            clock.tick_busy_loop(20)
            tick(world)
            if TIME >= duration:
                LAST_FRAME = True

    except KeyboardInterrupt:
        pass
    except carla.TimeoutException as e:
        print("TimeoutException: ", e)
    except Exception as e:
        print("Exception: ", e)
    finally:
        if world is not None:
            settings = world.get_settings()
            settings.synchronous_mode = False
            settings.fixed_delta_seconds = None
            world.apply_settings(settings)

        if client is not None:
            client.stop_replayer(True)
            client.set_replayer_time_factor(1)

if __name__ == '__main__':
    main()
```

**Section sources**

- [recorder_replay.py</a>

## 性能瓶颈与内存管理

在大规模场景回放时，性能瓶颈和内存管理成为关键问题。CARLA 通过以下方式优化性能和内存使用：

### 数据包过滤

系统只处理必要的数据包，忽略无关的数据包，以减少处理开销。

### 内存池

使用内存池技术来管理频繁分配和释放的小对象，减少内存碎片和提高性能。

### 异步处理

通过异步处理机制，将耗时的操作（如文件读取和网络通信）放在后台线程中执行，避免阻塞主线程。

### 缓存机制

缓存常用的 Actor 和状态信息，减少重复查询和计算。

**Section sources**

- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Recorder/CarlaReplayer.cpp#L694-L717" target="_blank">CarlaReplayer.cpp</a>
- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/LibCarla/source/carla/client/detail/Episode.cpp#L30-L36" target="_blank">Episode.cpp</a>

## 结论

CARLA 回放系统通过多种机制来检测和处理异常情况，确保回放过程的稳定性和可靠性。通过理解这些机制和策略，开发者可以更好地诊断和解决回放问题，构建更加健壮的自动驾驶模拟环境。
