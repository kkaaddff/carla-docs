# 高级工具集成

> **引用文件**
> **本文档引用的文件**

- [ecosys_synkrotron.md](https://github.com/carla-simulator/carla/blob/ue5-dev/Docs/ecosys_synkrotron.md)
- [bp_library.md](https://github.com/carla-simulator/carla/blob/ue5-dev/Docs/bp_library.md)
- [RayCastLidar.cpp](https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Sensor/RayCastLidar.cpp)
- [RayCastSemanticLidar.cpp](https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Sensor/RayCastSemanticLidar.cpp)
- [RayCastSemanticLidar.h](https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Sensor/RayCastSemanticLidar.h)
- [CameraInfo.cpp](https://github.com/carla-simulator/carla/blob/ue5-dev/LibCarla/source/carla/ros2/types/CameraInfo.cpp)
- [ActorBlueprintFunctionLibrary.cpp](https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Actor/ActorBlueprintFunctionLibrary.cpp)
- [ProceduralBuildingUtilities.h](https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/CarlaTools/Source/CarlaTools/Public/ProceduralBuildingUtilities.h)
- [ProceduralBuildingUtilities.cpp](https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/CarlaTools/Source/CarlaTools/Private/ProceduralBuildingUtilities.cpp)
- [OpenDriveToMap.cpp](https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/CarlaTools/Source/CarlaTools/Private/OpenDriveToMap.cpp)
- [OpenDriveToMap.h](https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/CarlaTools/Source/CarlaTools/Public/OpenDriveToMap.h)
- [CustomFileDownloader.cpp](https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/CarlaTools/Source/CarlaTools/Private/Online/CustomFileDownloader.cpp)
- [open3d_lidar.py](https://github.com/carla-simulator/carla/blob/ue5-dev/PythonAPI/examples/open3d_lidar.py)
- [visualize_multiple_sensors.py](https://github.com/carla-simulator/carla/blob/ue5-dev/PythonAPI/examples/visualize_multiple_sensors.py)
- [WeatherParameters.h](https://github.com/carla-simulator/carla/blob/ue5-dev/LibCarla/source/carla/rpc/WeatherParameters.h)
- [WeatherParameters.cpp](https://github.com/carla-simulator/carla/blob/ue5-dev/LibCarla/source/carla/rpc/WeatherParameters.cpp)

## 目录

1. [引言](#引言)
2. [鱼眼相机模型集成](#鱼眼相机模型集成)
3. [激光雷达物理模型集成](#激光雷达物理模型集成)
4. [SOTIF 场景生成工具集成](#sotif场景生成工具集成)
5. [静态场景创建工具](#静态场景创建工具)
6. [总结](#总结)

## 引言

Synkrotron 提供了一系列基于 CARLA 的高级工具和服务，用于自动驾驶仿真开发。这些工具包括鱼眼相机、激光雷达等传感器模型，SOTIF 场景生成工具，地图创建，静态场景创建以及动态场景重建等功能。本文档将详细介绍这些高级工具与 CARLA 的集成方法，涵盖广角视野的准确模拟、激光雷达多回波和反射率模拟、SOTIF 边缘案例测试以及快速构建定制化测试环境的方法。

**本节来源**

- [ecosys_synkrotron.md](https://github.com/carla-simulator/carla/blob/ue5-dev/Docs/ecosys_synkrotron.md)

## 鱼眼相机模型集成

Synkrotron 提供的鱼眼相机模型具有可配置的畸变参数，能够实现广角视野的精确模拟。在 CARLA 中，鱼眼相机通过特定的镜头参数来模拟真实的光学特性。

### 配置参数

鱼眼相机的主要配置参数包括：

- **fov** (_Float_) - 视场角
- **image_size_x** (_Int_) - 图像宽度
- **image_size_y** (_Int_) - 图像高度
- **lens_circle_falloff** (_Float_) - 镜头圆形衰减
- **lens_circle_multiplier** (_Float_) - 镜头圆形倍增器
- **lens_k** (_Float_) - 镜头 k 参数
- **lens_kcube** (_Float_) - 镜头 k 立方参数
- **lens_x_size** (_Float_) - 镜头 x 尺寸
- **lens_y_size** (_Float_) - 镜头 y 尺寸
- **role_name** (_String_) - 角色名称
- **sensor_tick** (_Float_) - 传感器更新间隔

### 使用示例

```python
import carla

client = carla.Client('localhost', 2000)
world = client.get_world()

# 获取蓝图库
blueprint_library = world.get_blueprint_library()

# 获取鱼眼相机蓝图
camera_bp = blueprint_library.find('sensor.camera.rgb')

# 设置鱼眼相机参数
camera_bp.set_attribute('fov', '180')  # 180度广角
camera_bp.set_attribute('lens_k', '-1.0')
camera_bp.set_attribute('lens_kcube', '0.0')
camera_bp.set_attribute('lens_circle_multiplier', '0.0')
camera_bp.set_attribute('lens_circle_falloff', '5.0')

# 创建相机变换
camera_transform = carla.Transform(carla.Location(x=2.0, z=1.8))

# 生成鱼眼相机
camera = world.spawn_actor(camera_bp, camera_transform)

# 定义回调函数处理图像数据
def process_image(image):
    # 处理鱼眼图像数据
    print(f"Received fisheye image: {image.width}x{image.height}")

# 设置监听器
camera.listen(process_image)
```

**本节来源**

- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Docs/bp_library.md#L22-L49" target="_blank">bp_library.md</a>
- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Actor/ActorBlueprintFunctionLibrary.cpp#L337-L492" target="_blank">ActorBlueprintFunctionLibrary.cpp</a>
- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/LibCarla/source/carla/ros2/types/CameraInfo.cpp#L47-L66" target="_blank">CameraInfo.cpp</a>

## 激光雷达物理模型集成

Synkrotron 的激光雷达模型支持可配置的快门模式和材料反射特性，能够模拟多回波和反射率等高级物理特性。

### 配置参数

激光雷达的主要配置参数包括：

- **channels** (_Int_) - 通道数
- **range** (_Float_) - 测量范围
- **points_per_second** (_Int_) - 每秒点数
- **rotation_frequency** (_Float_) - 旋转频率
- **upper_fov** (_Float_) - 上方视场角
- **lower_fov** (_Float_) - 下方视场角
- **atmosphere_attenuation_rate** (_Float_) - 大气衰减率
- **noise_stddev** (_Float_) - 噪声标准差
- **dropoff_general_rate** (_Float_) - 丢包通用率
- **dropoff_intensity_limit** (_Float_) - 强度丢包限制
- **dropoff_zero_intensity** (_Float_) - 零强度丢包
- **horizontal_fov** (_Float_) - 水平视场角
- **role_name** (_String_) - 角色名称
- **sensor_tick** (_Float_) - 传感器更新间隔

### 物理模型实现

激光雷达的物理模型在`ARayCastLidar`类中实现，主要包括以下几个关键功能：

1. **大气衰减计算**：根据距离计算信号衰减
2. **噪声模拟**：添加高斯噪声以模拟真实传感器噪声
3. **丢包模拟**：基于概率模拟信号丢失
4. **反射强度计算**：根据目标材质计算反射强度

```cpp
void ARayCastLidar::Set(const FLidarDescription &LidarDescription)
{
  Description = LidarDescription;
  LidarData = FLidarData(Description.Channels);
  CreateLasers();
  PointsPerChannel.resize(Description.Channels);

  // 计算丢包模型参数
  DropOffBeta = 1.0f - Description.DropOffAtZeroIntensity;
  DropOffAlpha = Description.DropOffAtZeroIntensity / Description.DropOffIntensityLimit;
  DropOffGenActive = Description.DropOffGenRate > std::numeric_limits<float>::epsilon();
}

ARayCastLidar::FDetection ARayCastLidar::ComputeDetection(const FHitResult& HitInfo, const FTransform& SensorTransf) const
{
  FDetection Detection;
  const FVector HitPoint = HitInfo.ImpactPoint;
  Detection.point = SensorTransf.Inverse().TransformPosition(HitPoint);

  const float Distance = Detection.point.Length();

  // 大气衰减计算
  const float AttenAtm = Description.AtmospAttenRate;
  const float AbsAtm = exp(-AttenAtm * Distance);

  // 反射强度计算
  Detection.intensity = AbsAtm;

  return Detection;
}

bool ARayCastLidar::PostprocessDetection(FDetection& Detection) const
{
  // 添加噪声
  if (Description.NoiseStdDev > std::numeric_limits<float>::epsilon()) {
    const auto ForwardVector = Detection.point.MakeUnitVector();
    const auto Noise = ForwardVector * RandomEngine->GetNormalDistribution(0.0f, Description.NoiseStdDev);
    Detection.point += Noise;
  }
  return true;
}
```

### 使用示例

```python
import carla

client = carla.Client('localhost', 2000)
world = client.get_world()

# 获取蓝图库
blueprint_library = world.get_blueprint_library()

# 获取激光雷达蓝图
lidar_bp = blueprint_library.find('sensor.lidar.ray_cast')

# 设置激光雷达参数
lidar_bp.set_attribute('channels', '64')
lidar_bp.set_attribute('range', '100')
lidar_bp.set_attribute('points_per_second', '500000')
lidar_bp.set_attribute('rotation_frequency', '20')
lidar_bp.set_attribute('upper_fov', '15')
lidar_bp.set_attribute('lower_fov', '-25')
lidar_bp.set_attribute('noise_stddev', '0.2')
lidar_bp.set_attribute('dropoff_general_rate', '0.1')
lidar_bp.set_attribute('dropoff_intensity_limit', '0.8')
lidar_bp.set_attribute('dropoff_zero_intensity', '0.4')

# 创建激光雷达变换
lidar_transform = carla.Transform(carla.Location(x=0.0, z=2.5))

# 生成激光雷达
lidar = world.spawn_actor(lidar_bp, lidar_transform)

# 定义回调函数处理点云数据
def process_lidar_data(point_cloud):
    # 处理激光雷达数据
    data = np.frombuffer(point_cloud.raw_data, dtype=np.dtype('f4'))
    data = np.reshape(data, (int(data.shape[0] / 4), 4))
    points = data[:, :-1]  # 3D坐标
    intensity = data[:, -1]  # 反射强度
    print(f"Received lidar data: {len(points)} points")

# 设置监听器
lidar.listen(process_lidar_data)
```

**本节来源**

- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Docs/bp_library.md#L182-L198" target="_blank">bp_library.md</a>
- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/Carla/Source/Carla/Sensor/RayCastLidar.cpp#L46-L141" target="_blank">RayCastLidar.cpp</a>
- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/PythonAPI/examples/open3d_lidar.py#L108-L127" target="_blank">open3d_lidar.py</a>
- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/PythonAPI/examples/visualize_multiple_sensors.py#L114-L128" target="_blank">visualize_multiple_sensors.py</a>

## SOTIF 场景生成工具集成

Synkrotron 的 SOTIF（预期功能安全）场景生成工具能够根据用户提供的 ODD（设计运行域）描述，识别重要场景元素并生成关键场景，帮助发现自动驾驶系统的未知不安全域。

### 工作原理

SOTIF 场景生成工具采用基于本体的方法，结合在 CARLA 中的迭代优化评估，实现以下功能：

1. **ODD 分析**：解析用户提供的设计运行域描述
2. **场景元素识别**：识别关键的交通参与者、道路结构和环境条件
3. **场景生成**：生成可能暴露系统弱点的边缘案例
4. **迭代优化**：在 CARLA 中评估生成的场景，并根据结果优化场景参数

### 集成方法

SOTIF 工具与 CARLA 的集成主要通过以下方式实现：

1. **OpenScenario 格式**：生成的场景以 OpenScenario 1.0 格式输出，可以直接在 CARLA 中加载和执行
2. **API 接口**：提供 RESTful API 或 Python API 与 CARLA 进行交互
3. **参数化场景**：支持动态调整场景参数，如天气条件、交通密度等

### 使用示例

```python
import carla
from sotif_generator import SOTIFScenarioGenerator

client = carla.Client('localhost', 2000)
world = client.get_world()

# 初始化SOTIF场景生成器
sotif_generator = SOTIFScenarioGenerator()

# 定义ODD描述
odd_description = {
    "operational_domain": "urban",
    "speed_range": [0, 60],
    "weather_conditions": ["clear", "rain"],
    "lighting_conditions": ["day", "night"],
    "road_types": ["two_way", "intersection"],
    "traffic_density": "medium"
}

# 生成SOTIF场景
sotif_scenarios = sotif_generator.generate_scenarios(odd_description, num_scenarios=10)

# 在CARLA中执行SOTIF场景
for scenario in sotif_scenarios:
    # 加载场景
    scenario_loader = carla.ScenarioRunner(world)
    scenario_loader.load_scenario(scenario)

    # 设置天气条件
    if scenario.weather == "rain":
        weather = carla.WeatherParameters.WetNoon
    elif scenario.weather == "clear":
        weather = carla.WeatherParameters.ClearNoon
    else:
        weather = carla.WeatherParameters.Default

    world.set_weather(weather)

    # 执行场景
    scenario_loader.start()

    # 监控系统行为
    while scenario_loader.running:
        world.tick()
        # 收集数据并分析系统表现
        analyze_system_behavior()

    # 评估结果
    evaluation_result = evaluate_scenario_performance()

    # 反馈给SOTIF生成器用于迭代优化
    sotif_generator.update_knowledge_base(scenario, evaluation_result)
```

**本节来源**

- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Docs/ecosys_synkrotron.md#L48" target="_blank">ecosys_synkrotron.md</a>
- [WeatherParameters.h](https://github.com/carla-simulator/carla/blob/ue5-dev/LibCarla/source/carla/rpc/WeatherParameters.h)
- [WeatherParameters.cpp](https://github.com/carla-simulator/carla/blob/ue5-dev/LibCarla/source/carla/rpc/WeatherParameters.cpp)

## 静态场景创建工具

Synkrotron 的静态场景创建工具结合了高精地图、3D 资产开发和程序化建模技术，为用户创建 3D 静态场景或数字孪生。

### 功能特点

1. **高精地图集成**：支持从激光雷达扫描数据创建高精地图
2. **3D 资产开发**：提供丰富的 3D 模型库
3. **程序化建模**：支持程序化生成建筑、道路等复杂结构
4. **OpenDrive 输出**：生成的场景可以输出为 OpenDrive 文件，直接在 CARLA 中使用

### 实现细节

静态场景创建工具的核心功能在`ProceduralBuildingUtilities`类中实现：

```cpp
UCLASS()
class CARLATOOLS_API AProceduralBuildingUtilities : public AEditorUtilityActor
{
  GENERATED_BODY()

public:
  // 生成建筑纹理
  UFUNCTION(BlueprintCallable, Category="Procedural Building Utilities")
  void GenerateImpostorTexture(const FVector& BuildingSize);

  // 生成建筑几何
  UFUNCTION(BlueprintCallable, Category="Procedural Building Utilities")
  class UProceduralMeshComponent* GenerateImpostorGeometry(const FVector& BuildingSize);

  // 将程序化建筑烘焙为静态网格
  UFUNCTION(BlueprintCallable, Category="Procedural Building Utilities")
  void CookProceduralBuildingToMesh(const FString& DestinationPath, const FString& FileName);

  // 在场景中放置建筑
  UFUNCTION(BlueprintCallable, Category="Procedural Building Utilities")
  void PlaceBuilding(AActor* Parent, TArray<UHierarchicalInstancedStaticMeshComponent*> Components);

  // 生成建筑材质
  UFUNCTION(BlueprintCallable, Category="Procedural Building Utilities")
  class UMaterialInstanceConstant* GenerateBuildingMaterialAsset(
      const FString& DuplicateParentPath,
      const FString& DestinationPath,
      const FString& FileName);
};
```

### 地图创建流程

1. **数据采集**：获取激光雷达扫描数据
2. **地图生成**：使用`OpenDriveToMap`工具生成 OpenDrive 地图
3. **地形创建**：创建匹配真实世界的地形
4. **资产放置**：在地图上放置 3D 资产
5. **场景优化**：优化场景性能和视觉效果

```cpp
void UOpenDriveToMap::CreateMap()
{
  if( MapName.IsEmpty() )
  {
    UE_LOG(LogCarlaToolsMapGenerator, Error, TEXT("Map Name Is Empty") );
    return;
  }

  // 下载或加载OSM数据
  FileDownloader->Url = Url;
  FileDownloader->ResultFileName = MapName;

  // 转换OSM到OpenDrive
  FileDownloader->DownloadDelegate.BindUObject( this, &UOpenDriveToMap::ConvertOSMInOpenDrive );
  FileDownloader->StartDownload();
}

void UOpenDriveToMap::CreateTerrain( const int MeshGridSize, const float MeshGridSectionSize)
{
  // 创建地形网格
  for( int i = 0; i <= NumI; i++ )
  {
    for( int j = 0; j <= NumJ; j++ )
    {
      FVector2D Offset( MinBox.X + i * MeshGridSize, MinBox.Y + j * MeshGridSize);
      CreateTerrainMesh(i * NumJ + j, Offset, MeshGridSize, MeshGridSectionSize );
    }
  }
}
```

### 使用示例

```python
import carla
from static_scene_creator import StaticSceneCreator

client = carla.Client('localhost', 2000)
world = client.get_world()

# 初始化静态场景创建器
scene_creator = StaticSceneCreator()

# 方法1：从激光雷达数据创建地图
lidar_data_path = "/path/to/lidar/data"
hd_map = scene_creator.create_hd_map_from_lidar(lidar_data_path)

# 方法2：从OSM数据创建地图
osm_data_url = "https://example.com/map.osm"
open_drive_file = scene_creator.convert_osm_to_opendrive(osm_data_url)

# 加载生成的地图
world.load_map(open_drive_file)

# 创建程序化建筑
building_params = {
    "width": 20.0,
    "depth": 15.0,
    "height": 10.0,
    "floors": 3,
    "roof_type": "flat"
}

building = scene_creator.create_procedural_building(building_params)

# 在指定位置放置建筑
building_transform = carla.Transform(carla.Location(x=100, y=200, z=0))
scene_creator.place_building(building, building_transform)

# 添加其他静态资产
assets_to_add = [
    {"type": "tree", "count": 50},
    {"type": "street_light", "count": 20},
    {"type": "traffic_sign", "count": 10}
]

for asset in assets_to_add:
    scene_creator.add_static_assets(asset["type"], asset["count"])

# 优化场景
scene_creator.optimize_scene()

# 保存场景
scene_creator.save_scene("custom_urban_scene")
```

**本节来源**

- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Docs/ecosys_synkrotron.md#L51" target="_blank">ecosys_synkrotron.md</a>
- [ProceduralBuildingUtilities.h](https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/CarlaTools/Source/CarlaTools/Public/ProceduralBuildingUtilities.h)
- [ProceduralBuildingUtilities.cpp](https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/CarlaTools/Source/CarlaTools/Private/ProceduralBuildingUtilities.cpp)
- <a href="https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/CarlaTools/Source/CarlaTools/Private/OpenDriveToMap.cpp#L146-L175" target="_blank">OpenDriveToMap.cpp</a>
- [OpenDriveToMap.h](https://github.com/carla-simulator/carla/blob/ue5-dev/Unreal/CarlaUnreal/Plugins/CarlaTools/Source/CarlaTools/Public/OpenDriveToMap.h)

## 总结

本文档详细介绍了 Synkrotron 提供的高级工具与 CARLA 的集成方法。通过这些工具，用户可以实现：

1. **精确的传感器模拟**：包括鱼眼相机的广角视野模拟和激光雷达的多回波、反射率等物理特性模拟
2. **全面的安全测试**：利用 SOTIF 场景生成工具测试自动驾驶系统的边缘案例
3. **高效的场景创建**：通过静态场景创建工具快速构建定制化的测试环境

这些工具的集成大大增强了 CARLA 仿真平台的能力，为自动驾驶系统的开发和测试提供了强有力的支持。

**本节来源**

- [ecosys_synkrotron.md](https://github.com/carla-simulator/carla/blob/ue5-dev/Docs/ecosys_synkrotron.md)
- 所有相关源文件
